(ns mighty.dcoref
  (:require [clojure.string :as str :refer (join)]
            [clojure.pprint :refer (pprint)]
            [mighty.config :refer (config)])
  (:import (edu.stanford.nlp.pipeline StanfordCoreNLP
                                      Annotation)
           (edu.stanford.nlp.ling CoreAnnotations$SentencesAnnotation
                                  CoreAnnotations$NamedEntityTagAnnotation
                                  CoreAnnotations$TokensAnnotation
                                  CoreAnnotations$MentionTokenAnnotation)
           (edu.stanford.nlp.dcoref CorefCoreAnnotations
                                    CorefCoreAnnotations$CorefChainAnnotation
                                    CorefCoreAnnotations$CorefGraphAnnotation)
           edu.stanford.nlp.trees.tregex.TregexPattern
           edu.stanford.nlp.trees.tregex.tsurgeon.Tsurgeon
           edu.stanford.nlp.trees.TreeCoreAnnotations$TreeAnnotation
           (java.lang.reflect.Method))
  )

(def ^:private props
  ;; props are properties used by the Stanford CoreNLP system. We establish a pipeline of annotation this way.
  (doto (java.util.Properties.)
    (.put "annotators" "tokenize, ssplit, pos, lemma, ner, parse, dcoref")
    (.put "parse.maxlen" (str (-> config :nlp :max-sentence-length)))
    (.put "pos.maxlen" (str (-> config :nlp :max-sentence-length)))))

(def ^:private pipeline
  ;; pipeline is the NLP stack we use to process our text.
  (StanfordCoreNLP. props))

(defn- annotated-doc [s]
  ;; This function take our text and passes it through the NLP pipeline.
  (.process pipeline s))


;; Examples using data from a document about quantum teleportation.
;;(def raw-document (slurp "/home/peter/Documents/test-text/spooky-action.txt"))
(def raw-document (slurp "universe.txt"))

raw-document
(annotated-doc "\"During the early universe, we expected cosmic inflation â€” this is a rapid expansion of the universe right after the Big Bang,\" said study co-author Robert Hogan, a doctoral candidate in physics at King's College in London. \"This expansion causes lots of stuff to shake around, and if we shake it too much, we could go into this new energy space, which could cause the universe to collapse.\"")
(annotated-doc "Though those events would have occurred 13.8 billion years ago, a telescope at the South Pole known as the Background Imaging of Cosmic Extragalactic Polarization (BICEP2) recently detected the faint traces of cosmic inflation in the background microwave radiation that pervades the universe: in particular, characteristic twisted or curled waves called the B-mode pattern. (Other scientists have already begun to question the findings, saying the results may just be from dust in the Milky Way.)")
(annotated-doc "But the theory of cosmic inflation is still speculative, and some physicists hint that what looked like primordial gravitational waves to the BICEP2 telescope may actually be signals from cosmic dust in the galaxy, said Sean Carroll, a physicist at the California Institute of Technology and author of \"The Particle at the End of the Universe: How the Hunt for the Higgs Boson Leads Us to the Edge of a New World\" (Dutton Adult, 2012).")
(def annotated-document (annotated-doc raw-document))
(def dcoref-chains (.get annotated-document CorefCoreAnnotations$CorefChainAnnotation))
(def chain (map #(.getValue %) dcoref-chains))
(def representative-mentions (map #(.getRepresentativeMention %) chain))
(def annotated-sentences (.get annotated-document CoreAnnotations$SentencesAnnotation))

(defn- tokens-sentence
  ;; Takes the processed document and recovers the token annotations from it.
  [annotated-sentences sentNum]
  (.get (nth annotated-sentences sentNum) CoreAnnotations$TokensAnnotation))

(defn- sentence-2-tokens
  ;; takes a single sentence and produces the token objects.
  [sentence]
  (.get sentence CoreAnnotations$TokensAnnotation))

(defn- rep-mention-coordinates
  ;; Takes a representitive mention and pulls the coordinates for it as a vector of [sentence number, start index and end index]. These values are corrected to 0-start array coordinates.
  ;; For example the first sentence is 0 not 1.
  [mention]
  (let [sentNum    (dec (.sentNum mention))
        startIndex (dec (.startIndex mention))
        endIndex   (dec (.endIndex   mention))]
    (vector sentNum startIndex endIndex))
)

(defn- select-tokens
  ;; This takes the token list and the start and end coordinates and produces a list of the token objects.
  [tokens startIndex endIndex]
  (->> tokens
     (split-at startIndex)
     second
     (split-at (- endIndex startIndex))
     first))

(defn- coord-to-tokens
  ;; This takes annotated sentences and coordinates in a vector (as generated by rep-mention-coordinates for example) and produces token objects.
  [annotated-sentences [sentNum startIndex endIndex]]
  (let [tokens (.get (nth annotated-sentences sentNum) CoreAnnotations$TokensAnnotation)]
    (select-tokens tokens startIndex endIndex)))

(defn hash-tokens
  ;; Takes token coordinates and produces token maps.
  ;; as annotated sentences
  ;; tc token coordinates
  [as tc]
  (map #(hash-map :word (.originalText %) :ner (.ner %) :tag (.tag %)) (coord-to-tokens as tc)))

(def noun-tags '("NN" "NNS" "NNP" "NNPS"))
(def good-body-tags '("DT" "IN" "RP" "TO" "JJ" "JJR" "JJS" "NN" "NNS" "NNP" "NNPS"))
(def good-first-tags '("NN" "NNS" "NNP" "NNPS"))

(defn noun-tag? [tag]
  (some #(= tag %) noun-tags))

(defn good-body-tags? [token]
  (some #(= (:tag token) %) good-body-tags))

(defn good-first-tag? [token]
  (some #(= (:tag token) %) good-first-tags))

(defn just-text
  ;; ht hash tokens
  [ht]
  (map :word ht))

(defn text-tag
  ;; ht hash tokens
  [ht]
  (map #(str (:word %) " - " (:tag %)) ht))

(defn get-rm-text [rm as]
  (let [ht (->> rm
       rep-mention-coordinates
       (hash-tokens as))]
    (if (good-first-tag? (first ht))
      (flatten (list (:word (first ht)) (map :word (filter good-body-tags? (rest ht)))))
      (map :word (filter good-body-tags? (rest ht)))
    )
  )
)

(get-rm-text (first representative-mentions) annotated-sentences)
(:tag (get-rm-text (first representative-mentions) annotated-sentences))

;; example
(map #(get-rm-text % annotated-sentences) representative-mentions)

(map #(.tag %) (sentence-2-tokens (nth annotated-sentences 3)))
(map #(.originalText %) (sentence-2-tokens (nth annotated-sentences 3)))
(.getMentionMap (nth chain 3))
(.getSource (first (.keySet (.getMentionMap (nth chain 3)))))
(.getTarget (first (.keySet (.getMentionMap (nth chain 3)))))

(nth (tokens-sentence annotated-sentences 0) 7)

(.size dcoref-chains)
(count (.getMentionMap (nth chain 5)))
(map #(count (.getMentionMap %)) chain)
(nth chain 8)
(.getRepresentativeMention (nth chain 8))
(first (.getMentionMap (nth chain 8)))
(.getSource (first (.keySet (.getMentionMap (nth chain 8)))))
(.getTarget (first (.keySet (.getMentionMap (nth chain 8)))))

(count annotated-sentences)
(nth annotated-sentences 30)

(defn get-rep-mention-span [chain]
  (->> chain
       .getRepresentativeMention
       .mentionSpan))

(get-rep-mention-span (nth chain 8))

(defn chain-rm-targets[chain annotated-sencences]
  (let [rm-representation (get-rep-mention-span chain)]))




;;TODO
;; Now match representative-mentions with individual chain mentions
;; Try to weed out non PRP and @ mentions. Instead create new associations.
;; Example. It looked like an airplane. Replace It with representative-mention
;; and if airplane has a more specific mention add that to the associations.







